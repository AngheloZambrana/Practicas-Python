# Practicas-Python
Subire ejercicios practicando el lenguaje python
Ire subiendo paginas y enlaces de donde voy sacando los links:
https://pythondiario.com/ejercicios-de-programacion-python

# Índice

## Ejercicios Parte 1

1. [Función max()](#función-max)
2. [Función max_de_tres()](#función-max_de_tres)
3. [Función para calcular la longitud de una lista o cadena](#función-para-calcular-la-longitud-de-una-lista-o-cadena)
4. [Función para determinar si un carácter es vocal](#función-para-determinar-si-un-carácter-es-vocal)
5. [Funciones sum() y multip()](#funciones-sum-y-multip)
6. [Función inversa()](#función-inversa)
7. [Función es_palindromo()](#función-es_palindromo)
8. [Función superposicion()](#función-superposicion)
9. [Función generar_n_caracteres()](#función-generar_n_caracteres)
10. [Procedimiento histograma()](#procedimiento-histograma)

## Ejercicios Parte 2

1. [La función max_in_list()](#la-función-max_in_list)
2. [La función mas_larga()](#la-función-mas_larga)
3. [La función filtrar_palabras()](#la-función-filtrar_palabras)
4. [Programa para contar letras mayúsculas](#programa-para-contar-letras-mayúsculas)
5. [Programa para convertir números binarios en enteros](#programa-para-convertir-números-binarios-en-enteros)
6. [Programa para calcular edades y años de nacimiento](#programa-para-calcular-edades-y-años-de-nacimiento)
7. [Programa para imprimir cantidad de personas con edades superiores a 20](#programa-para-imprimir-cantidad-de-personas-con-edades-superiores-a-20)
8. [Programa para imprimir cantidad de nombres que comienzan con una letra dada](#programa-para-imprimir-cantidad-de-nombres-que-comienzan-con-una-letra-dada)
9. [Función para contar vocales en una palabra](#función-para-contar-vocales-en-una-palabra)
10. [Función para determinar si un año es bisiesto](#función-para-determinar-si-un-año-es-bisiesto)

## Juego del dragon
1. [Clase juego](#clase-juego)
2. [Función contadorPuntos()](#funcion-contadorPuntos())

## Juego Master Mind
1. [Explicacion juego](#explicacion-juego)
2. [Clase juego Master mind](#clase-juego-master-mind)

## Juego Palabras Que Riman
1. [Explicacion del juego](#explicacion-del-juego)
2. [Clase Verificador de palabras que riman](#clase-verificador-de-palabras-que-riman)
3. [Clase Palabras que riman simplificada](#clase-palabras-que-riman-simplificada)

## Calculo de crecimiento de una inversion con tasa de interes
1. [Explicacion del problema](#explicacion-del-problema)
2. [Clase calculdora de crecimiento con tasa de interes](#clase-calculadora-de-crecimiento-con-tasa-de-interes)
3. [Ejemplo de uso](#ejemplo-de-uso)

## Calculo de crecimiento de una inversion con tasa de interes
1. [Explicacion del problema Descuentos](#explicacion-del-problema-descuentos)
2. [Clase descuento por sorteo](#clase-descuento-por-sorteo)

## Generacion De Factura por Galeria de Productos
1. [Explicacion del problema Factura](#explicacion-del-problema-factura)
2. [Clase productos](#clase-productos)
3. [Clase factura](#clase-factura)

## Calculadora de tarifas de alquiler de peliculas
1. [Explicacion del problema tarifa](#explicacion-del-problema-tarifa)
2. [Categorias y Tarifas](#categorias-y-tarifas)
3. [Clase categorias](#clase-categorias)
4. [Clase calculadoraTarifa](#clase-calculadoraTarifa)

### Manejo De Base De Datos con SQLite3
- [Manejo de SQLite3 en nuestro codigo (1ra clase)](#manejo-de-sqlite3-en-nuestro-código-1ra-clase)
- [Manejo de SQLite3 en nuestro codigo (2da clase)](#manejo-de-sqlite3-en-nuestro-código-2da-clase)
- [Resultado de la clase "mi_base_de_datos.db"](#resultado-de-la-clase-mi_base_de_datosdb)


# Ejercicios Parte 1

Estos primeros ejercicios son de una pagina con ejercicios en linea: https://pythondiario.com/2013/05/ejercicios-en-python-parte-1.html
En la carpeta `Ejercicios` se trabajó en los siguientes problemas:

1. ## Función max()
   - Descripción: Esta función toma dos números como argumento y devuelve el mayor de ellos.
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/70dddad0-0e99-4cae-90c7-9a6616ec04c3)
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/4706dcbe-297c-4ead-9e9f-ac952bfd78e5)

2. ## Función max_de_tres()  
   - Descripción: Esta función toma tres números como argumentos y devuelve el mayor de ellos.
  
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/baf540e3-3be3-4355-88be-4c8f45f4aaad)
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/1a0ec9a4-29dd-47ec-94de-4e2690097976)
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/5f0383b5-4380-470d-893c-78a83e2a0961)
     
3. ## Función para calcular la longitud de una lista o cadena
   - Descripción: Esta función calcula la longitud de una lista o una cadena dada.
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/50b02f5f-dcc6-4ca8-880d-0a287c0b1ead)

4. ## Función para determinar si un carácter es vocal
   - Descripción: Esta función toma un carácter como argumento y devuelve True si es una vocal, de lo contrario devuelve False.
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/521fff56-dbb9-4b49-b14c-47d2a231256e)
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/ce7e9668-b92a-47be-b2d4-2e8c76066872)

5. ## Funciones sum() y multip()
   - Descripción: La función sum() suma todos los números de una lista. La función multip() multiplica todos los números de una lista.
     
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/e14e4a05-2038-4698-b8d2-1bb28c966f2f)

6. ## Función inversa()
   - Descripción: Esta función calcula la inversión de una cadena. Por ejemplo, la cadena "estoy probando" debería devolver la cadena "odnaborp yotse".

     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/21756d0c-768f-4e23-9190-429c9fd8d610)
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/f46ad643-f916-4b1e-8958-4e26ec7aae01)

7. ## Función es_palindromo()
   - Descripción: Esta función reconoce palíndromos, es decir, palabras que tienen el mismo aspecto escritas invertidas. Por ejemplo, es_palindromo("radar") debería devolver True.

     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/8c632090-fe9c-4ba9-b4c3-f16230f2f05d)
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/51d6c9c1-b0f3-4c85-b845-104d4cab6110)

8. ## Función superposicion()
   - Descripción: Esta función toma dos listas y devuelve True si tienen al menos 1 miembro en común, o False de lo contrario. La función está escrita usando el bucle for anidado.

     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/0ee7714e-e510-4280-8d91-2067e080a233)
     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/9b3abffd-95f1-4219-a02d-99ece9046ec9)


9. ## Función generar_n_caracteres()
   - Descripción: Esta función toma un entero n y un caracter, y devuelve el caracter multiplicado por n. Por ejemplo, generar_n_caracteres(5, "x") debería devolver "xxxxx".

     ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/1e6cf454-d0bd-41eb-9e8a-0382add12313)

10. ## Procedimiento histograma()
    - Descripción: Esta función toma una lista de números enteros e imprime un histograma en la pantalla. Por ejemplo, si se le pasa [4, 9, 7], debería imprimir:
    ```
    ****
    *********
    *******
    ```
    
   ![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/0c05b9fc-c518-410c-87e4-809ea4dc7ee7)

# Ejercicios en Python (Parte 2)
Estos son los ejercicios trabajados como segunda parte de estas practicas, el link de los ejercicios es: https://pythondiario.com/2013/05/ejercicios-en-python-parte-2.html

## La función max_in_list()
**Descripción:** La función `max()` del ejercicio 1 (primera parte) y la función `max_de_tres()` del ejercicio 2 (primera parte), solo van a funcionar para 2 o 3 números. Supongamos que tenemos más de 3 números o no sabemos cuántos números son. Escribir una función `max_in_list()` que tome una lista de números y devuelva el más grande.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/25b25de9-298f-44dc-ba0b-01490e8569e5)

## La función mas_larga()
**Descripción:** Escribir una función `mas_larga()` que tome una lista de palabras y devuelva la más larga.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/b1443e94-c23f-4186-a366-fd8ed0f3aebe)

## La función filtrar_palabras()
**Descripción:** Escribir una función `filtrar_palabras()` que tome una lista de palabras y un entero n, y devuelva las palabras que tengan más de n caracteres.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/bb60ea88-3cf6-4f79-8801-65a60bc880cb)

## Programa para contar letras mayúsculas
**Descripción:** Escribir un programa que le diga al usuario que ingrese una cadena. El programa tiene que evaluar la cadena y decir cuántas letras mayúsculas tiene.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/72784dc3-be66-4be4-91cc-4c8b0b80a35d)

## Programa para convertir números binarios en enteros
**Descripción:** Construir un pequeño programa que convierta números binarios en enteros.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/78cdcde4-b00b-4c7a-8953-ceba98d5349a)

## Programa para calcular edades y años de nacimiento
**Descripción:** Escribir un pequeño programa donde:
- Se ingresa el año en curso.
- Se ingresa el nombre y el año de nacimiento de tres personas.
- Se calcula cuántos años cumplirán durante el año en curso.
- Se imprime en pantalla.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/c3ca36d4-9d06-4b58-95ae-53fcc04a7dbf)

## Programa para imprimir cantidad de personas con edades superiores a 20
**Descripción:** Definir una tupla con 10 edades de personas. Imprimir la cantidad de personas con edades superiores a 20. Puedes variar el ejercicio para que sea el usuario quien ingrese las edades.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/7904d5f4-6e85-437b-954c-8f0a36f1181a)

## Programa para imprimir cantidad de nombres que comienzan con una letra dada
**Descripción:** Definir una lista con un conjunto de nombres, imprimir la cantidad de nombres que comienzan con la letra 'a'. También se puede hacer elegir al usuario la letra a buscar. (Un poco más emocionante)

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/57f74d1d-2051-4b17-a7fb-da71461886ab)

## Función para contar vocales en una palabra
**Descripción:** Crear una función `contar_vocales()`, que reciba una palabra y cuente cuántas letras "a" tiene, cuántas letras "e" tiene y así hasta completar todas las vocales. Se puede hacer que el usuario sea quien elija la palabra.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/bf27ce1e-4544-4fa9-984e-2734eb8c03be)

## Función para determinar si un año es bisiesto
**Descripción:** Escribir una función `es_bisiesto()` que determine si un año determinado es un año bisiesto. Un año bisiesto es divisible por 4, pero no por 100. También es divisible por 400.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/55779a69-7e9f-4a26-996a-3033d3749d06)

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/fa077423-9cf6-4527-9866-79e80e00bc00)

# Juego del Dragón

## Enlaces a los artículos del juego:
- [Parte 1](https://pythondiario.com/2013/06/juego-en-python-reino-del-dragon-parte1.html)
- [Parte 2](https://pythondiario.com/2013/06/juego-en-python-reino-del-dragon-parte2.html)

## Subindice

- [Cómo jugar al Reino del Dragón](#como-jugar-al-reino-del-dragón)
- [Definición de la función introduccion()](#definición-de-la-función-introduccion)
- [Definición de la función CambiarCueva()](#definición-de-la-función-cambiarcueva)
- [Definición de la función cheqcueva(CambiarCueva)](#definición-de-la-función-cheqcuevacambiarcueva)
- [Viendo los resultados del juego](#viendo-los-resultados-del-juego)
- [Decidir en qué cueva está el dragón amistoso](#decidir-en-qué-cueva-está-el-dragón-amistoso)
- [Donde comienza el programa realmente](#donde-comienza-el-programa-realmente)
- [Llamando a las funciones de nuestro programa](#llamando-a-las-funciones-de-nuestro-programa)
- [Dando la opción de jugar de nuevo](#dando-la-opción-de-jugar-de-nuevo)

## Clase Juego

## Como jugar al Reino del Dragón
En este juego, el jugador se encuentra en una tierra llena de dragones. Los dragones viven en sus cuevas y en ellas guardan sus tesoros. Algunos dragones son buenos y compartirán su tesoro, otros dragones son codiciosos y hambrientos y se comerán a cualquiera que pise su cueva. El jugador se encuentra frente a las dos cuevas, una con un dragón amable y otra con un dragón hambriento. El jugador tiene que elegir a cual cueva entrar, sin saber de ante mano donde esta uno u el otro. 

## Definición de la función introduccion()

import random
import time

Empezamos importando 2 módulos: el modulo random y el modulo time. Como vimos en el juego anterior, el modulo random nos va a ser útil para elegir números al azar. En este juego también vamos a usar el modulo time para hacer algunas funciones relacionadas con el tiempo.

Definición de la función introduccion()
Como su nombre los dice, la función introduccion(), cuando es llamada brinda al usuario la presentación del juego.

Las funciones se componen de la siguiente manera: la palabra clave def, seguido del nombre que va a tener la función con paréntesis, y luego dos puntos, a partir de ahí, todo lo que este con sangría debajo de la función es lo que se llama el bloque de la función, lo que nuestra función va a realizar.
La declaración def significa que estamos creando una función y podemos llamarla cuando la necesitemos. Después de definir nuestra función, podemos llamarla de la misma manera que llamamos a otras funciones. Una ves sea llamada, se ejecuta lo que esta dentro del bloque de dicha función.
También decir que cuando el programa llega al código def, este no es ejecutado, si no que la función se ejecuta una ves sea llamada. Cuando la función es llamada, el código salta al def para saber lo que tiene que hacer.
Cuando llamamos a la función introduccion(), la ejecución del programa salta a la linea def introduccion(): y cuando este bloque de código se termina, el programa vuelve a la linea donde fue llamada la función.

## Definición de la función CambiarCueva()

Aqui definimos la funcion CambiarCueva(). Esta funcion le hara elegir al usuario entre la cueva 1 o la cueva 2.
Dentro de esta funcion se crea una nueva variable llamada cueva que almacena una cadena vacía. Después, comenzamos con un ciclo while,  que se va a repetir si el usuario no elije 1 o 2 (este ciclo se utiliza para evitar errores, si el usuario elije otro numero o cualquier otro caracter, el ciclo se repite)
La primera ves que se llama la función, la sentencia:
while cueva != "1" and cueva != "2":
Va a evaluar lo que esta dentro de la variable cueva (que en un principio esta vacía), por lo tanto  cueva != "1" es verdadero y cueva != "2" también es verdadero (si estas dos condiciones son verdaderas la función entra en el ciclo)
Una ves que la función entre en el ciclo, va a preguntar al jugador en que cueva quiere entrar. Cualquier cosa que el jugador escriba se va a guardar en la variable cueva: cueva = raw_input(). Si el jugador escribió 1 o 2 el while va a ser falso y por lo tanto va a terminar retornando lo que esta guardado en la variable cueva: return cueva. Si el jugador escribió cualquier otra cosa, el while va a ser verdadero y por lo tanto se va a repetir.

## Definición de la función cheqcueva(CambiarCueva)
 
Ahora definimos la función cheqcueva(). Notar que ponemos CambiarCueva dentro de los paréntesis. Los nombres de las variables que están dentro de los paréntesis son llamadas parámetros.
Los parámetros son los valores de entrada que recibe una función. Si la función no tiene nada entre los paréntesis es porque no necesita ningún dato de entrada, pero nuestra función cheqcueva(CambiarCueva), necesita un dato de entrada.

## Viendo los resultados del juego

print ("Te acercas a la Cueva...")
time.sleep(2)

Mostramos un poco de texto en la pantalla y luego llamamos a la función time.sleep(). El modulo time tiene una función sleep() que hará una pausa en el programa durante los segundos que le pasemos como parámetro (en nuestro caso pasamos 2 segundos).

print ("Esta oscuro y tenebroso...")
time.sleep(2)

Hacemos lo mismo con un poco mas de texto y la espera de 2 segundos. Estas pausas cortas le dan un poco de suspenso al juego en lugar de mostrar todo el texto de una ves.

print ("Un gran dragon salta delante tuyo, abre su boca y...")
print ("")
time.sleep(2)

Que es lo que pasa ahora? Como el programa decide que es lo que pasa?

## Decidir en qué cueva está el dragón amistoso

FriendlyCueva = random.randint (1, 2)

Ahora vamos a decidir al azar (con el modulo random) en que cueva esta el dragón amistoso. Nuestra llamada a la función random.randint(1, 2) nos devolverá 1 o 2 y guardara este valor en la variable FriendlyCueva.

Ahora comprobamos si el numero entero de la cueva que elegimos ("1" o "2") es igual a la cueva seleccionada al azar para encontrar el dragón amistoso. Pero, un momento, el valor de  CambiarCueva era una cadena (raw_input devuelve cadenas) y el valor de FriendlyCueva es un entero (porque random.randint() devuelve enteros). No se puede comparar cadenas y numeros porque siempre seran diferentes ("1" no es lo mismo que 1). Lo que hacemos es pasar a cadena la variable FriendlyCueva (str(FriendlyCueva)).

Luego sigue la palabra clave else que se ejecuta si la condición en la sentencia if es falsa. Pensémoslo así: si la condición se cumple, hacer esto, si no, hacer lo otro.
Podemos notar que siempre se ponen dos puntos al final del if, else, while y def. Los dos puntos marcan el final de la declaración, y nos dice que la linea siguiente es el comienzo de un nuevo bloque.

## Donde comienza el programa realmente

EmpezarNuevo = ("si")

Esta es la primera linea de código que no es una declaracion def, o sea, no esta dentro de una función. En esta linea realmente es donde comienza nuestro juego. Las declaraciones def anteriores simplemente definen las funciones que esperan ser llamadas. Las funciones deben ser definidas antes de ser llamadas.

while EmpezarNuevo == ("s") or EmpezarNuevo == ("si"):

Este ciclo while va a ser verdadero mientras que EmpezarNuevo sea igual a "s" o a "si". Por eso es que inicializamos la variable EmpezarNuevo con el valor "si", para que la primera ves que entramos al juego el ciclo sea verdadero y se inicie el mismo.

## **Llamando a las funciones de nuestro programa**

introduccion()

Aquí llamamos a la función introduccion(), esta no es una función que python incorpore, si no que es una función hecha por nosotros, definida anteriormente en el programa y que podemos utilizarla cuando nosotros queramos. Cuando se llama a esta función, la ejecución del programa salta a la primera linea de la función.

NumCaverna = CambiarCueva()

Esta linea también llama una función creada por nosotros. Recordar que la función CambiarCueva() permite elegir al jugador a que cueva quiere entrar. Lo que elija el jugador se va a guardar en la variable NumCaverna.

cheqcueva(NumCaverna)

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/a048a0c8-171f-4e76-8693-328aaaa29309)


Esta linea llama a nuestra función cheqcueva() con el argumento NumCueva (que va a ser 1 o 2 dependiendo de lo que elija el jugador).  Esta es la funcion que va a retornar "Te entrega el tesoro..." o
"El dragon te come de un bocado...." dependiendo del ingreso del jugador y del azar del juego.

## Dando la opción de jugar de nuevo

print ("Quieres jugar de nuevo? (si o no)")
EmpezarNuevo = raw_input()

Una ves que el juego se termine, se le preguntara al jugador si quiere hacerlo de
nuevo. Dependiendo de lo que ingrese, el ciclo while se termina o sigue.

2. ## Función contadorPuntos()

La función `contadorPuntos()` se encarga de manejar el flujo del juego y el conteo de puntos acumulados por el jugador. A continuación se explica paso a paso su funcionamiento:

1. **Definición de la función contadorPuntos():** Esta función se encarga de manejar el flujo del juego y el conteo de puntos.

2. **Inicialización de variables:** La variable `puntos` se inicializa en 0 para llevar el conteo de los puntos acumulados por el jugador. La variable `EmpezarNuevo` se inicializa con el valor "si" para permitir que el jugador inicie el juego.

3. **Bucle while para el juego:** Se utiliza un bucle `while` para permitir que el jugador juegue tantas veces como desee. El bucle continuará mientras `EmpezarNuevo` sea "si" o "sí", independientemente de si el jugador ganó o perdió la última partida.

4. **Llamada a las funciones del juego:** Dentro del bucle `while`, se llama a las funciones `introduccion()`, `CambiarCueva()` y `cheqcueva(NumCaverna)`, que son funciones definidas en el archivo importado `JuegoDelDragon.py`. Estas funciones se encargan de presentar el juego al jugador, permitirle elegir una cueva y verificar si ganó o perdió.

5. **Conteo de puntos:** Después de verificar el resultado del juego, se suma la cantidad de puntos ganados en la variable `puntos`.

6. **Mostrar resultado y preguntar por jugar de nuevo:** Se muestra en pantalla la cantidad de puntos ganados en la última partida y el total acumulado hasta el momento. Luego se pregunta al jugador si desea jugar de nuevo.

7. **Definición de la función `cheqcueva(cueva_elegida)`:** Esta función es la misma que se encuentra en el archivo importado `JuegoDelDragon.py`. Se encarga de simular el encuentro con el dragón y determinar si el jugador gana o pierde puntos en función de la cueva elegida.

# Juego Master Mind

## Explicacion juego

Escribe un programa que te permita jugar a una versión simplificada del
juego Master Mind. El juego consistirá en adivinar una cadena de números distintos. Al principio, el programa debe pedir la longitud de la adena (de 2 	a 9 cifras). Después el programa debe ir pidiendo que intentes adivinar la cadena de números. En cada intento, el programa informará de cuántos números han sido acertados (el programa considerará que se ha acertado un número si coincide el valor y la posición).
- Dime la longitud de la cadena: 4
- Intenta adivinar la cadena: 1234
- Con 1234 has adivinado 1 valores. Intenta adivinar
- la cadena: 1243
- Con 1243 has adivinado 0 valores. Intenta adivinar
- la cadena: 1432
- Con 1432 has adivinado 2 valores. Intenta adivinar
- la cadena: 2431
- Con 2431 has adivinado 4 valores.
- Felicidades

## Clase juego Master mind

## Definición de la función `masterMind()`

La función `masterMind()` es el corazón del juego, donde ocurre toda la lógica del mismo. Comienza pidiendo al usuario la longitud de la cadena que debe adivinar. Luego genera una cadena aleatoria de números distintos dentro del rango especificado por el usuario.

**Generación de la cadena aleatoria**

- `longitud = int(input("Dime la longitud de la cadena: "))`: Pide al usuario que introduzca la longitud de la cadena que desea adivinar.
- `lista = []`: Inicializa una lista vacía donde se almacenará la cadena aleatoria.
- `for _ in range(longitud):`: Itera sobre el rango de la longitud especificada por el usuario.
  - `lista.append(random.randint(0, 9))`: Agrega un número aleatorio entre 0 y 9 (inclusive) a la lista.

**Bucle principal del juego**

El juego se ejecuta dentro de un bucle infinito, continuando hasta que el usuario adivine la cadena completa.
- `while True:`: Inicia un bucle infinito para continuar el juego.
- `numeroUsuario = input("Intenta adivinar la cadena: ")`: Pide al usuario que introduzca su intento para adivinar la cadena.
- `if len(numeroUsuario) != longitud:`: Comprueba si la longitud del intento del usuario coincide con la longitud de la cadena generada.
- `intento = [int(digito) for digito in numeroUsuario]`: Convierte la cadena ingresada por el usuario en una lista de números enteros.
- `aciertos = sum(1 for i in range(longitud) if intento[i] == lista[i])`: Calcula cuántos números ha adivinado el usuario comparando cada elemento del intento con la lista generada aleatoriamente.
- `print(f"Con {numeroUsuario} has adivinado {aciertos} valores.")`: Muestra cuántos números ha adivinado el usuario en su intento.
- `if aciertos == longitud:`: Comprueba si el usuario ha adivinado todos los números en la posición correcta.
- `print("¡Felicidades!")`: Muestra un mensaje de felicitación si el usuario ha adivinado la cadena completa.
- `break`: Sale del bucle infinito para finalizar el juego.

**Llamada a la función `masterMind()`**

Finalmente, se llama a la función `masterMind()` para comenzar el juego.

# Juego Palabras Que Riman

## Explicacion del juego

El juego consiste en un programa que pide al usuario ingresar dos palabras y determina si riman o no. Si coinciden las tres últimas letras, se indica que riman. Si coinciden solo las dos últimas letras, se dice que riman un poco. En caso contrario, se indica que no riman.

## Clase Verificador de palabras que riman

Este programa verifica si dos palabras riman utilizando un enfoque basado en comparación de las últimas letras de las palabras.

El funcionamiento del programa es el siguiente:

1. Se le pide al usuario que ingrese dos palabras, que se almacenan en las variables palabra1 y palabra2. Estas palabras se convierten a minúsculas para evitar problemas de comparación.
2. Cada palabra se convierte en una lista de caracteres utilizando list(palabra). Esto permite acceder a cada letra individualmente.
3. Se calculan los índices de las últimas tres letras de cada palabra (comparador1, comparador2, comparador3 para la primera palabra; Scomparador1, Scomparador2, Scomparador3 para la segunda palabra), restando 3, 2 y 1, respectivamente, del tamaño de cada lista de palabras.
4. Se comparan las letras de las dos palabras en las posiciones correspondientes a las últimas tres letras.
    - Si todas coinciden, imprime "Ambas palabras riman".
    - Si solo las dos últimas coinciden, imprime "Solo riman 2 letras de tus dos palabras".
    - Si solo la última coincide, imprime "Solo rima 1 letra de tus dos palabras".
    - Si ninguna de las tres coincide, imprime "Sus palabras no riman".

## Clase Palabras que riman simplificada

Este programa es una implementación simplificada del juego de palabras que riman que se hizo inicialmente. A continuación, explico cómo funciona:

- Se define una función llamada rimas(), que no toma ningún argumento.
- Dentro de la función:
    - Se solicita al usuario que ingrese dos palabras utilizando la función input(). Estas palabras se almacenan en las variables palabra1 y palabra2, y se convierten a minúsculas usando el método lower() para evitar problemas de comparación debido a diferencias de mayúsculas y minúsculas.
    - Se obtienen las últimas tres letras de cada palabra utilizando el slicing de Python. Esto se hace tomando los últimos tres elementos de la cadena usando la notación [-3:] y se almacenan en las variables ultimas_tres_letras_palabra1 y ultimas_tres_letras_palabra2.
    - Se obtienen las últimas dos letras de cada palabra de manera similar y se almacenan en las variables ultimas_dos_letras_palabra1 y ultimas_dos_letras_palabra2.
    - Se comparan las últimas tres letras de ambas palabras. Si coinciden, se imprime "Ambas palabras riman.".
    - Si no coinciden las últimas tres letras, se compara si coinciden las últimas dos letras de ambas palabras. Si coinciden, se imprime "Las palabras riman un poco.".
    - Si no coinciden ni las últimas tres ni las últimas dos letras de ambas palabras, se imprime "Las palabras no riman.".
- Finalmente, se llama a la función rimas() para ejecutarla.


# Calculo de crecimiento de una inversion con tasa de interes

## Explicacion del problema

Este programa solicita al usuario una cantidad de dinero, una tasa de interés y un número de años. Luego, calcula y muestra por pantalla cuánto se habrá convertido el capital inicial después de esos años, si cada año se aplica la tasa de interés introducida.

## Clase calculdora de crecimiento con tasa de interes

Aquí está cómo funciona paso a paso:

1. El programa solicita al usuario tres entradas:
   - La cantidad de capital inicial en dólares (C).
   - La tasa de interés anual en porcentaje (x).
   - El número de años (n) durante los cuales se aplicará la tasa de interés.

2. Luego, utiliza la fórmula de interés compuesto para calcular el valor futuro de la inversión después del período especificado:
   - T = C * (1 + x/100)^n
     
Donde:
- C es el capital inicial.
- x es la tasa de interés anual.
- n es el número de años.
- T es el valor futuro de la inversión.

3. Finalmente, imprime el resultado en la pantalla, mostrando cuánto será el capital después del número de años especificado.

## Ejemplo de uso
Supongamos que tienes una cantidad de $10,000 dólares con una tasa de interés del 4.5% anual. Quieres saber cuánto será ese capital después de 20 años. El programa te dará la respuesta.
Después de 20 años, su capital se habrá convertido en 24117.14 dólares.


# Calculo de crecimiento de una inversion con tasa de interes

## Explicacion del problema Descuentos

Este programa simula un sistema de descuentos por sorteo en una tienda. Primero, solicita al usuario que ingrese la cantidad total de compras realizadas. Si la cantidad es inferior a $100.00, el programa informa al usuario que no aplica a la promoción. Si la cantidad es igual o superior a $100.00, el programa genera aleatoriamente un número del 1 al 5, cada uno correspondiendo a un color de bola diferente. Dependiendo del color de la bola aleatoria, se aplicará un descuento específico sobre el total de la compra del usuario.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/0fb272af-629e-45b4-8064-3b7cd204f71c)

## Clase descuento por sorteo

La funcionalidad del programa se puede resumir de la siguiente manera:

1. La función `descuentosColor()` solicita al usuario que ingrese la cantidad total de la compra mediante la función `input()`. Este valor se almacena en la variable `cantidadInicial` como un número de punto flotante.

2. Se utiliza un bloque `try-except` para manejar cualquier excepción que pueda ocurrir si el usuario ingresa un valor no numérico. En caso de que ocurra una excepción, se imprime un mensaje de error y se termina la ejecución de la función.

3. Si la cantidad total de la compra ingresada por el usuario es igual o mayor a $100.00, el programa continúa ejecutándose. De lo contrario, se imprime un mensaje indicando que el cliente no aplica a la promoción y se finaliza la ejecución de la función.

4. Si la cantidad total de la compra es igual o mayor a $100.00, el programa simula un sorteo generando aleatoriamente un número del 1 al 5 (inclusive) utilizando `random.randint(1,5)` y lo guarda en la variable `color`. Este número representa el color de una bola extraída.

5. Se utilizan declaraciones `if-elif-else` para determinar qué acción tomar según el color de la bola extraída:
    - Si el color es 1, se imprime un mensaje indicando que no hay descuento.
    - Si el color es 2, se aplica un descuento del 10%.
    - Si el color es 3, se aplica un descuento del 20%.
    - Si el color es 4, se aplica un descuento del 25%.
    - Si el color es 5, se aplica un descuento del 50%.
    - En cada caso, se calcula el nuevo total a pagar (`resultado`) después de aplicar el descuento y se muestra al usuario.

6. Si la cantidad total de la compra es menor a $100.00, se imprime un mensaje indicando que el cliente no aplica a la promoción.

7. Finalmente, se llama a la función `descuentosColor()` para ejecutar el programa.

# Generacion De Factura por Galeria de Productos

## Explicacion del problema Factura

De la galería de productos, el usuario introducirá el código y el número de unidades del producto que desea comprar. El programa determinará el total a pagar, como una factura. Una variante a este ejercicio que lo haría un poco más complejo sería dar la posibilidad de seguir ingresando diferentes códigos de productos con sus respectivas cantidades, y cuando el usuario desee terminar el cálculo de la factura completa con todas sus compras.

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/cbe93fe4-091f-4c15-a4df-500dbe81d8e3)


## Clase productos

En esta clase trabajamos proporciona dos funciones y la descripción de su funcionalidad es la siguiente:

### Función `productosGaleria()`

Esta función devuelve dos listas:
- Una lista de productos que contiene nombres de productos como "Camisa", "Cinturón", etc.
- Una lista de códigos que contiene números enteros del 1 al número total de productos en la lista.

### Función `asignarPrecio(producto, precios)`

Esta función toma dos parámetros:
- El nombre de un producto.
- Una lista de precios.

Basándose en el nombre del producto, esta función devuelve el precio correspondiente desde la lista de precios proporcionada. Las reglas son las siguientes:
- Si el producto es "Calcetines", devuelve el primer precio en la lista de precios.
- Si el producto es "Gorras", "Cinturón" o "Corbata", devuelve el segundo precio en la lista de precios.
- Si el producto es "Faldas", devuelve el tercer precio en la lista de precios.
- Si el producto es "Camisa" o "Chaqueta", devuelve el cuarto precio en la lista de precios.
- Si el producto es "Pantalon", devuelve el quinto precio en la lista de precios.
- Si el producto es "Sueter", devuelve el sexto precio en la lista de precios.
- En caso contrario, devuelve el precio en la posición 7 de la lista de precios.

## Clase factura

Dentro del archivo se describe detalladamente el funcionamiento de la función `generarFactura()` que se encarga de todo el proceso de generación de la factura. A continuación, se detallan los pasos que realiza:

1. **Inicialización de Variables**: 
    - Obtiene la lista de productos y códigos utilizando la función `productosGaleria()`.
    - Define la lista de precios de los productos.

2. **Inicialización del Carrito**: 
    - Crea un diccionario vacío `carrito` para almacenar los productos seleccionados por el usuario.

3. **Bucle de Compras**: 
    - Entra en un bucle infinito que permite al usuario agregar productos al carrito.
    - El usuario ingresa el código del producto y la cantidad deseada.

4. **Validación del Código**: 
    - Verifica si el código ingresado por el usuario corresponde a un producto válido.
    - Si no es válido, muestra un mensaje de error y solicita un nuevo código.

5. **Cálculo del Subtotal**: 
    - Utiliza la función `asignarPrecio()` para obtener el precio del producto seleccionado.
    - Calcula el subtotal multiplicando el precio por la cantidad.

6. **Actualización del Carrito**: 
    - Si el producto ya está en el carrito, actualiza la cantidad y el subtotal.
    - Si no está en el carrito, lo agrega con la cantidad y el subtotal.

7. **Finalización de la Compra**: 
    - Si el usuario ingresa un código de producto igual a 0, el bucle se interrumpe y se finaliza la compra.

8. **Cálculo del Total**: 
    - Calcula el total sumando los subtotales de todos los productos en el carrito.

9. **Impresión de la Factura**: 
    - Imprime la factura detallando los productos, las cantidades, los precios unitarios, los subtotales y el total a pagar.

Esto asegura que la generación de la factura se realice de manera eficiente y precisa, proporcionando al usuario toda la información necesaria sobre sus compras.



# Calculadora de tarifas de alquiler de peliculas

## Explicacion del problema tarifa

## Explicación del problema

Este programa muestra primero el listado de categorías de películas y pide al usuario que introduzca el código de la categoría de la película. Posteriormente, solicita al usuario que introduzca el número de días de atraso en la devolución, y muestra al final el total a pagar.

## Categorias y Tarifas

| Categoría        | Precio  | Código | Recargo/Día de atraso |
|------------------|---------|--------|------------------------|
| FAVORITOS        | $2.50   | 1      | $0.50                  |
| NUEVOS           | $3.00   | 2      | $0.75                  |
| ESTRENOS         | $3.50   | 3      | $1.00                  |
| SUPER ESTRENOS   | $4.00   | 4      | $1.50                  |

## Clase categorias

La clase `categorias` proporciona dos funciones importantes para el cálculo de tarifas de alquiler de películas:

### Función categorias()

Esta función devuelve una tupla con cuatro elementos:

- `listaCategorias`: Una lista de nombres de categorías de películas.
- `codigos`: Una lista de códigos de categorías de películas.
- `precios`: Una lista de precios correspondientes a cada categoría de películas.
- `deudas`: Una lista de recargos por día de atraso en la devolución de películas.

Estos elementos están predefinidos en la función y se utilizan para categorizar las películas y determinar sus tarifas de alquiler.

### Función asignarDeuda(categoria, deudas)

Esta función toma dos argumentos:

- `categoria`: El nombre de la categoría de la película.
- `deudas`: La lista de recargos por día de atraso en la devolución.

Se utiliza para asignar el recargo correspondiente por día de atraso en la devolución de una película según su categoría. Utiliza una serie de condicionales `if-elif-else` para determinar qué recargo corresponde a la categoría de la película.

Si la categoría de la película no coincide con ninguna de las categorías predefinidas, imprime un mensaje indicando que la categoría no se encuentra en la lista.

Estas funciones son esenciales para el funcionamiento de la calculadora de tarifas de alquiler de películas, ya que proporcionan información sobre las categorías de películas y ayudan a calcular los recargos por día de atraso en la devolución.

## Clase calculadoraTarifa

La clase `calculadoraTarifa` contiene una función `calcularDeuda()` que se encarga de ejecutar la lógica principal de la calculadora de tarifas de alquiler de películas.

### Función `calcularDeuda()`

- Utiliza un bucle `while True` para permitir que el programa se ejecute continuamente hasta que el usuario decida salir.
- Obtiene la información de las categorías de películas, códigos, precios y recargos por día de atraso en la devolución llamando a la función `categorias()` desde el módulo `TarifasDeAlquilerPeliculas.categorias`.
- Solicita al usuario que introduzca el código de la categoría de la película mediante la función `input()`. Si el código introducido está en la lista de códigos de categorías, continúa con el proceso.
- Posteriormente, solicita al usuario que introduzca el número de días de retraso en la devolución mediante otra llamada a `input()`.
- Utiliza el código de la categoría para obtener el nombre de la categoría y el precio correspondiente de la lista de categorías y precios.
- Llama a la función `asignarDeuda()` desde el módulo `TarifasDeAlquilerPeliculas.categorias` para obtener el recargo por día de atraso en la devolución.
- Calcula el total a pagar multiplicando el recargo por día de atraso por el número de días de retraso.
- Muestra el total a pagar al usuario.
- Le pregunta al usuario si desea salir. Si el usuario ingresa '1', el bucle se rompe y el programa termina.

Esta función encapsula la lógica principal de la calculadora de tarifas de alquiler de películas y maneja la interacción con el usuario de manera efectiva.


## Manejo de SQLite3 en nuestro codigo (1ra clase)

### Importación de la biblioteca sqlite3:

```python
import sqlite3
```

Esta línea importa la biblioteca sqlite3, que proporciona una interfaz para trabajar con bases de datos SQLite en Python.

### Conexión a la base de datos:

```python
conn = sqlite3.connect('mi_base_de_datos.db')
```

Aquí se establece una conexión con la base de datos mi_base_de_datos.db utilizando la función connect() de la biblioteca sqlite3. Si la base de datos no existe, esta función la creará automáticamente.

### Creación de un cursor:

```python
cursor = conn.cursor()
```

Se crea un cursor utilizando el método cursor() de la conexión. El cursor se utiliza para ejecutar comandos SQL en la base de datos.

### Creación de la tabla de empleados:

```python
cursor.execute('''
    CREATE TABLE IF NOT EXISTS empleados (
        id INTEGER PRIMARY KEY,
        nombre TEXT NOT NULL,
        apellido TEXT NOT NULL,
        sueldo_base REAL NOT NULL,
        afap TEXT NOT NULL,
        fecha_ingreso TEXT NOT NULL,
        cantidad_hijos INTEGER NOT NULL
    )
''')
```

Aquí se ejecuta una instrucción SQL para crear una tabla llamada empleados en la base de datos. La tabla tiene varios campos como id, nombre, apellido, sueldo_base, etc. El modificador IF NOT EXISTS asegura que la tabla solo se cree si no existe ya en la base de datos.

### Guardar cambios y cerrar conexión:

```python
conn.commit()
conn.close()
```

Finalmente, se guardan los cambios en la base de datos utilizando el método commit() de la conexión. Luego, se cierra la conexión con la base de datos utilizando el método close().

## Manejo de SQLite3 en nuestro codigo (2da clase)

### Clase ProgramaGestionEmpleados:

```python
def __init__(self, nombre_bd):
    self.nombre_bd = nombre_bd
    self.crear_tabla_empleados()
```

Este método inicializa la clase ProgramaGestionEmpleados con el nombre de la base de datos y llama al método crear_tabla_empleados() para asegurarse de que la tabla de empleados esté creada en la base de datos.

### Método crear_tabla_empleados:

```python
def ingresar_empleado(self):
    try:
        # Capturar datos del empleado
        nombre = input("Ingrese el nombre del empleado: ")
        apellido = input("Ingrese el apellido del empleado: ")
        sueldo_base = float(input("Ingrese el sueldo base del empleado: "))
        afap = input("Ingrese la AFP del empleado: ")
        fecha_ingreso = input("Ingrese la fecha de ingreso del empleado (YYYY-MM-DD): ")
        fecha_ingreso += ' 00:00:00'  # Agregar hora 00:00:00
        fecha_ingreso = datetime.datetime.strptime(fecha_ingreso, "%Y-%m-%d %H:%M:%S")
        cantidad_hijos = int(input("Ingrese la cantidad de hijos del empleado: "))

        # Conexión a la base de datos
        conn = sqlite3.connect(self.nombre_bd)
        cursor = conn.cursor()

        # Inserción de datos del empleado en la tabla
        cursor.execute('''
            INSERT INTO empleados (nombre, apellido, sueldo_base, afap, fecha_ingreso, cantidad_hijos)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (nombre, apellido, sueldo_base, afap, fecha_ingreso, cantidad_hijos))

        # Guardar cambios y cerrar conexión
        conn.commit()
        conn.close()

        print("Empleado ingresado correctamente.")

    except Exception as e:
        print("Error al ingresar empleado:", str(e))
```

Este método permite ingresar un nuevo empleado. Captura los datos del empleado desde la entrada estándar, los inserta en la tabla de empleados y guarda los cambios en la base de datos.

### Método calcular_pagos:

```python
def calcular_pagos(self):
    try:
        # Conexión a la base de datos
        conn = sqlite3.connect(self.nombre_bd)
        cursor = conn.cursor()

        # Obtener datos de los empleados
        cursor.execute('''
            SELECT nombre, apellido, sueldo_base, afap, fecha_ingreso, cantidad_hijos
            FROM empleados
        ''')
        empleados = cursor.fetchall()

        # Cálculos de pagos para cada empleado
        for empleado in empleados:
            # Realizar cálculos individuales por empleado

        # Cálculos de promedios de pagos

        # Guardar cambios y cerrar conexión

    except Exception as e:
        print("Error al calcular pagos:", str(e))
```

Este método ejecuta el programa principal, que muestra un menú de opciones al usuario y ejecuta la acción correspondiente según la opción seleccionada.

### Inicialización del programa:

```python
if __name__ == "__main__":
    programa = ProgramaGestionEmpleados('mi_base_de_datos.db')
    programa.ejecutar_programa()
```

En esta parte del código, se crea una instancia de la clase ProgramaGestionEmpleados con el nombre de la base de datos y se ejecuta el programa principal.

## Resultado de la clase "mi_base_de_datos.db"

![image](https://github.com/AngheloZambrana/Practicas-Python/assets/101211793/4adb1320-9d7d-4063-9ca0-82693d0612ff)

Como se puede ver esa es la estructura en la que se muestran las tablas, con los datos que ingresamos, esto se nos muestra gracias a la extension en nuestro IDE.
